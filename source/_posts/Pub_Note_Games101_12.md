---
title: Games101 12.Geometry 3
---

## Mesh Operations: Geometry Processing

![Alt text](image.png)

Mesh Subdivision：
![Alt text](image-1.png)

- 增加三角形的数量让表面更平滑
- 随着显卡的发展，三角形的数量不是太大的问题

Mesh Simplification：
![Alt text](image-2.png)

- 减少网格数量，但保持连接关系

Mesh Regularization：
![Alt text](image-3.png)

- 对不规则的三角形进行正则化，让三角形更规则

## Mesh Subdivision

### Loop Subdivision

![Alt text](image-4.png)

- 前面我们提到在使用 displacement map 的时候使用细分来增加三角形，这样才能赶得上纹理的频率
- 细分有两个步骤
  - 增加三角形的数量
  - 调整三角形的位置

要怎么增加三角形的数量呢？
![Alt text](image-5.png)

- 将三角形的三条边的中点连接，就可以得到四个三角形
- 我们把新的顶点和旧的顶点分开谈论
- 为什么叫 loop subdivision，这个 loop 和循环没有关系，只是发明这个算法的人的名字叫 loop

subdivision update：
![Alt text](image-6.png)

- 新生成的这个白点计算方式就是上图的公式
- 具体这个权重是怎么算的，这里就不说了

![Alt text](image-7.png)

- 一部分保留自己的位置，一部分受周围的影响
- n 是图论里边的度的概念，就是这个顶点连接的边的数量
- u 是仅仅是一个和度有关的数
- 如果它连接的边越多，那么它就越不重要，由周围的顶点决定。

最后得到的结果如下：
![Alt text](image-8.png)

### Catmull-Clark Subdivision (General Mesh)

![Alt text](image-9.png)

- 这个 catmull 就是今年的图灵奖得主之一，这是他广为人知的一个贡献
- loop subdivision 只能用于三角形网格，而 catmull-clark 可以用于各种不同的网格
- 定义两个概念，非四边形面和奇异点

同样的我们要先引入不同的点：

- 每条边都取它的中点
- 每个面也取它的中间的点
- 然后把边上的中点和面上的中点都连接起来

![Alt text](image-10.png)

- 新增的两个点的度是 3，是奇异点，因为它要和三角形的三条边相连。
- 所以我们发现，对非四边形面做这个操作引入的就是奇异点。
- 第一次引入后，原本的非四边形面都会消失，变成一个奇异点，继续细分奇异点数量就不变了。
- 继续细分网格变得越来越光滑。
  ![Alt text](image-11.png)

下面是点的更新规则：
![Alt text](image-12.png)

![Alt text](image-13.png)

- 上边 Loop subdivision 产生了各种缝（不连续的地方），这些缝是有明确的理论分析的，会在哪些地方形成缝，最后收敛了之后，它的结果会怎么样。

Pixar’s “Geri’s Game”：
![Alt text](image-14.png)

- 是大家认为最早的一批应用曲面细分技术做的动画

## Mesh Simplification

![Alt text](image-15.png)

- 有些情况下为了提升性能，不希望顶点太多，特别是在移动端的计算上
- 另外对于远处的物体，我们不需要那么多的顶点，所以我们可以根据距离来简化网格
- 不过几何的层次结构是很难做的，特别是涉及到什么时候做切换，并且有个平滑的过渡

![Alt text](image-16.png)

- 提供一种方法叫做边坍缩，就是把两个顶点坍缩成一个点，这样这条边就不再存在了

介绍一个概念叫做：二次误差度量（quadric error metrics）

![Alt text](image-17.png)

- 就是去算哪些边是重要的，哪些边不重要可以被坍缩
- 这里的二次指的是平方的意思，而不是做两次
- 找到一个新的点代替上边三个点，让这个新的三角形跟原来的多边形尽可能保持它们的轮廓形状一致
- 找这个点到原本的这几个面（虚线表示）的距离的平方和最小

![Alt text](image-18.png)

- 每个边都有一个让二次误差最小的点。我们以贪心的方式从所有边中最小二次度量误差中最小的边开始坍缩。

![Alt text](image-19.png)

- 不过涉及到一个问题，就是坍缩一条边会影响到其他边的二次度量误差
- 所以我们需要一个数据结构既能随时拿到最小的边，又能对其他边进行更新，这个数据结构就是优先队列或者也叫堆。
- 还有一个问题是，贪心算法只是保证了局部的最优解，全局的最优解没法保证。不过实际中，这种方法效果还是不错的。

![Alt text](image-20.png)

## Shadow Mapping

![Alt text](image-21.png)

- 前面提到着色是一个局部的事情，只考虑着色点，不考虑其他物体对这个着色点的影响。着色解决不了阴影问题。
- 光栅化对于全局的问题是很难解决的。
- 不渲染阴影的话，会感觉东西都浮在空中，因为阴影能够给大家一些物体和物体接触的感觉。

![Alt text](image-22.png)

- 这是一个图像空间的算法，不需要知道场景的几何信息
- 核心思想是，如果一个点不在阴影里，那么这个点一定是光源和相机都能看到的
- 经典的 shadow mapping 只能处理点光源，这里讨论的也是点光源
- 然后这种阴影通常会有一个非常明显的阴影边界，要么在阴影里，要么不在阴影里，这种阴影叫硬阴影。之后再讨论软阴影。

Pass 1：从光源看向场景
![Alt text](image-23.png)

- 虚拟的放个摄像机在光源位置，然后渲染整个场景，记录深度信息，这个深度信息就是 shadow map
  Pass 2：从相机看向场景
  ![Alt text](image-24.png)
  ![Alt text](image-25.png)
- 当我看到某个点时，把它投影回光源的虚拟相机，看看会在图像的哪个位置，然后比较这个位置的深度和之前记录的深度，如果一致，说明这个点是可见的，否则是在阴影里。
- 不一致则是在阴影里，这个点是光源看不到的。

![Alt text](image-26.png)
![Alt text](image-27.png)
![Alt text](image-29.png)
![Alt text](image-28.png)
![Alt text](image-30.png)

- 判断相等很困难，因为涉及到浮点数本身精度的问题。再加上屏幕空间本身像素位置也会有差异。
- 所以人们提出方法，比如不判断相等，只要大于之前记录的深度，就认为在阴影里。但还是解决不了问题，有些值太接近，就会有各种数值精度的问题。
- 所以又引入了 bias，只要大于之前记录的深度加上一个很小的值，就认为在阴影里。（仍然会造成各种问题）
- shadowmap 如果分辨率很低，会有锯齿。
- 而且涉及到两个 pass，对性能也会有影响
- 并且只能做硬阴影

![Alt text](image-31.png)
不过 shadowmap 还是游戏以及早期电影中的主流技术。

软阴影是怎么来的呢？
![Alt text](image-32.png)

- 光源有一定大小，完全看不到光源的地方是本影，部分看到光源的地方是半影。
