---
title: Games101 14.Ray Tracing 2(Acceleration & Radiometry)
---

![Alt text](image.png)

- GTC：GPU Technology Conference，由 NVIDIA 主办的 GPU 技术大会
- DLSS：Deep Learning Super Sampling，由 NVIDIA 开发的一种图像增强技术，比如将 720p 的图像放大到 4k，而且看上去不模糊。[DLSS 2.0 - 重新定义 AI 渲染](https://zhuanlan.zhihu.com/p/116211994)
- RTXGI：Real-Time Ray Tracing Global Illumination，实时光线追踪全局光照。由于 RTX 技术的发展，原本是离线的算法，现在逐步的被搬到实时渲染里面来。[RTXGI](https://developer.nvidia.com/rtxgi)

## Acceleration Structure

### Uniform Spatial Partitions(Grids)

前面我们讲到光线跟 AABB 的这样的求交，我们可以认为这个是一个很快的操作。所以我们的思想就是，在判断跟物体的交点之前先对外边的盒子进行求交。

![Alt text](image-1.png)

- 跟物体相交的格子都涂成灰色，不考虑什么内部，所以中间的这块不涂。

![Alt text](image-2.png)

- 光线打出去和这些盒子相交，如果盒子里有物体，那么就说明光线有可能和盒子里的物体有交点。
- 然后再判断光线和物体的交点，如果没有交点就继续往下走，直到找到第一个交点。
- 有一个问题是，怎么知道光线下一次要打到那个盒子。这个其实跟如何光栅化一条线是一样的道理。是有一个特定的算法（Bresenham 算法）的。

![Alt text](image-3.png)

- 格子太稀疏了起不到作用，格子太密集了要不断和盒子求交，效率就下来了，所以要找到一个平衡。

![Alt text](image-4.png)

- 人们发现了一些启发式的算法，就是找到一个常数乘以场景中物体的数量，这个常数是大家试出来的，没什么意义。

![Alt text](image-5.png)
![Alt text](image-6.png)

- 像体育场中间的一个茶壶这样的场景，光线要穿过很多盒子才能找到茶壶，效率就很低。
- 这是早期大家的一个简单尝试，但是在某些应用上这个方法仍然是挺好用的，特别是在一些 GPU 实现的算法上。

## Space Partitions

![Alt text](image-7.png)

- 空间划分简单来说就是，稀疏的地方用大格子，密集的地方用小格子。
- 左边这个叫做 Octree，中文名字叫做八叉树。它是一个节点有八个子节点的树。不过这里画的是二维的，所以实际是四叉树。对于每个子节点，再划分成四块，直到某个条件满足，比如说这个格子里没有物体了，或者只有一个物体了，就不再划分了。
- 但是八叉树有个问题，在二维空间中是四叉树，在三维空间中是八叉树，如果再高维度就不好办了。所以人们发明了 KD-Tree。
- KD-Tree 是一种二叉树，每次都是沿着某一个轴把它给砍开。以三维为例，按照 xyzxyz 这样循环划分。这样就可以保证空间不会变得越来越窄。
- 最右边的是 BSP-Tree，它也是一种二分的方法，不过它的划分方法不是横平竖直的，而是沿着某个方向斜着划分。BSP-Tree 在高维度的时候会变得越来越复杂，比如四维空间就需要用一个超平面来划分。

### KD-Tree

![Alt text](image-8.png)
![Alt text](image-9.png)

- 对于 ABCD 这些节点来说，我们需要记录它们会被划分成什么样的格子。
- 而这些几何体只存在叶子节点上。

![Alt text](image-10.png)

- KD-Tree 并没有规定划分一定要在中间

我们来看一下光线追踪怎么使用这个结构
![Alt text](image-11.png)

- 当和父节点相交的时候，就要判断子节点是否有交点
- 光线会和叶子节点中的所有几何体做相交计算
- 没有相交的节点就不用再往下走了

不过 KD-Tree 也存在一些问题：

- 三角形和盒子的相交判断比较困难，尤其是三角形完全在盒子内部时，没有一条边和盒子相交
- 一个几何体可能存在于多个叶子节点中，这样就会重复存储

### Object Partitions & Bounding Volume Hierarchy (BVH)

BVH 时现在图形学里边应用非常广泛的一个结构，不管是实时的光线追踪还是离线，大家都在用这个结构。因为它解决了 KD-Tree 的两个问题。

整个 BVN 的构建过程如下：
![Alt text](image-12.png)
![Alt text](image-13.png)
![Alt text](image-14.png)

- BVH 划分的不是空间，而是把这些物体分成两个部分。然后到一定程度就不再划分了，比如一个节点里最多只有五个三角形。
- KD-Tree 是先划分空间，再考虑几何体跟盒子的相交。BVH 是先把几何体分成两部分，再求它的 bounding box。求 bounding box 也很容易，取它们的最小最大 xyz 就行。不需要涉及到求交。
- 另外 BVH 避免了 KD-Tree 的一个问题，就是一个几何体可能存在于多个叶子节点中。
- 不过 BVH 也有一个问题，它对空间不是严格的划分的，也就是这些 bounding box 它可以相交。当然相交也没有什么太大的问题，只是说划分的不够好。

实际上应该如何去划分一个节点呢？
![Alt text](image-15.png)

- 每次切的方向其实可以有不同的做法。可以是每次选择一个新的维度，比如这次选择 x，下次选择 y。也可以是每次选择最长的那个轴，这样可以保证划分的两部分差不多长。
- 位置上呢，可以选择中间的那个三角形，这样可以保证两边的三角形数量差不多。尽可能的保证搜索的深度小。然后对这个三角形取它的重心。
- 要在一个序列中找中位数，如果用排序来做的话是 O(nlogn)的，但实际上是可以在 O(n)的时间内解决的。这个算法叫做快速选择算法，它是受快速排序启发的，只对划分出来的两边进行操作。

![Alt text](image-16.png)

- BVH 同样是在叶子节点上存储几何体。

![Alt text](image-17.png)

- 算法的流程跟 KD-Tree 是一样的。

![Alt text](image-18.png)

## Radiometry（辐射度量学）

为什么要学习辐射度量学呢？
![Alt text](image-19.png)

- 之前我们在布林冯模型中定义了光的强度，但是这个强度是没有明确的物理意义的，我们做了一个简化。
- Whitted 风格的光线追踪，我们发现它看上去很假，因为我们做了很多简化，比如光的反射和折射都是完美的，而实际上是不可能的。

![Alt text](image-20.png)

- 所以辐射度量学用来从物理上精确地把光描述出来。

需要提一点的是：

- 我们关心光在空间上的属性，不关心时间上的属性。而且仍然是基于几何光学的，认为光是直线传播的，没有什么波动性质。

![Alt text](image-21.png)

- Radiant Energy：电磁辐射的能量，单位是焦耳
- Radiant Flux：辐射通量，单位是瓦特。也就是单位时间内的能量（或者按照大学物理来讲就是功率）。整个辐射度量学考虑的都是单位时间的性质。
- 在光学上想要描述一个物体的功率用另外一个单位叫做流明（lm），它描述的是光的亮度。

![Alt text](image-22.png)

- 从另一个角度，flux 我们可以理解为单位时间通过平面的光子数量。

![Alt text](image-23.png)

- 光源会辐射出各种不同的能量，我们需要定义这些能量。
- 物体表面会接收到多少能量。
- 光线在传播中的能量应该如何定义。

### Radiant Intensity

![Alt text](image-24.png)

- Radiant Intensity：单位立体角上的辐射通量，单位是瓦特/流明每立体角。

那什么是立体角呢？
![Alt text](image-25.png)

- 在平面上我们把角度用弧长来定义，立体角实际上就是把这个弧长延伸到三维空间中。
- 在立体角上积分可以得到整个球的表面积，也就是 $4\pi r^2$。

![Alt text](image-26.png)

- 大家常常会定义一个单位立体角，就是一个单位的面积除以它的半径。
- 弧长等于半径乘以角度
- 后面之所以是$rsin\theta  d\phi$是因为需要先投影到旋转的平面上

![Alt text](image-27.png)

![Alt text](image-28.png)

- 整个辐射度量学中，我们使用 omega 来表示方向
- 这个$\omega$可以用$\theta$和$\phi$来定义它的位置，然后可以通过$sin\theta d\theta d\phi$来算出它的一个单位立体角或者微分立体角。

![Alt text](image-29.png)

- intensity 可以通过 flux 除以单位立体角来定义，也就是说我们可以从任何一个方向上看过去，对应着它的亮度。

![Alt text](image-30.png)
