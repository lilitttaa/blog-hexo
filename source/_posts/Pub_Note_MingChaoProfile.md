---
title: 鸣潮多平台优化
---

https://www.bilibili.com/video/BV1BK411v7FY

## 字幕

00:00 大家好啊
00:01 我叫王波
00:02 现在在库洛游戏啊啊
00:04 我今天的分享呢
00:06 是关于明朝在多平台的一些效果和性能的一些
00:09 优化呃
00:10 分享可能会比较碎片化
00:12 另外一个呢就是我个人的语速可能会比较快啊
00:15 大家稍微见谅一点啊啊啊
00:19 现在就开始
00:22 啊这是我过往做过的一些游戏
00:24 然后呃昨天晚上刚好跟一个朋友吃饭的时候
00:27 就聊到这个事
00:29 就是我想找我第一款做过的游戏
00:31 就已经找不到了啊
00:33 从从业大概有接近 20 年了
00:35 有一个感触就是还能跟大家一起做游戏
00:38 都挺不容易的
00:50 啊先看看我们游戏的一个介绍
01:52 呃我们项目是一款啊开放世界的二次元
01:56 二次元的游戏
01:57 然后它的主要特性
01:58 第一个是大世界
01:59 第二个呢是 ST 的战斗
02:00 第三个字
02:01 还有一个特性
02:02 是类似于宝可梦的一个收集系统啊
02:04 刚才大家看视频
02:05 应该对我们游戏会有个整体印象
02:06 这样方便后面我再说一些事情的时候
02:09 大家能够了解为什么需要那样去做
02:13 啊因为一些时间的原因
02:15 所以我这边呢也不能面面俱到啊
02:17 今天的分享主要是挑三个比较
02:19 典型的方案来讲啊
02:20 第一个是讲我们为什么会啊
02:22 选一个 default shader 的这么一个管线啊
02:25 第二个呢就是讲我们啊
02:27 这 TA 大概是怎么去做优化的
02:29 对于二次元游戏来说啊
02:30 A 这一块其实是非常重要的啊
02:33 它的重要性可能都超过了啊
02:35 其他的像 PPPR 相关的一些游戏啊
02:38 第三个呢就是我们在实现 one one past four 的时候
02:41 碰到一些问题啊
02:42 这个问题还是两个两个大的问题吧
02:44 一个问题是呃就是关于马力的 GPU 的
02:47 另外一个问题是关于引擎本身的
02:49 然后第三个呢就是我们在实现大师啊
02:51 大世界的一个大规模的森林的时候
02:53 我们怎么样在多平台上去保证它的效果
02:55 和它的一个性能
03:00 啊第一个问题是我为什么要选 default 啊
03:03 一般来说移动端的用 mobile 是比较多的啊
03:06 用那个 MOBA 用那个 FORWORD 是比较多的啊
03:09 这个主要原因是
03:10 因为那个一般来说
03:11 我们如果说面对大规模的灯光
03:13 那我们一般都会要么就选 ford 加
03:15 要么就选择 defer 对吧啊
03:17 从性能角度来说是这样的
03:19 我们的同屏灯光是很多的啊
03:21 大概多少呢
03:22 大概可能同屏能够到 200 多盏吧
03:24 少的时候也有四五十帧以上
03:26 到晚上的时候
03:27 这种 TOT 晚上的时候就会更多
03:30 然后第二个呢就是因为我们选 def 的原因
03:33 是因为我们效果上还是有些追求的
03:35 比如说我们想做 SSR 啊
03:36 想在手机上做 GTAO 啊等等啊
03:39 第三个原因就是成本
03:40 开发成本成本来说啊
03:41 无论是走 ford 加或者说 default
03:44 对我们来说开发成本是差不太多的
03:46 所以我们经过权衡之后呢
03:47 然后我们就选了一个 default
03:50 但是 DVD 其实有他的问题
03:57 啊渲染 default 之后的话
03:59 那我们的 A 方案就只能选择后处理的 AA 了啊
04:02 这是我截了一张我们的游戏的图啊
04:05 大家可以看到整个游戏的话
04:07 那个在 A 之前啊
04:08 它的剧情是非常多的
04:10 就无论我们的角色的勾边呢
04:12 或者说我们的啊草啊啊
04:14 或者说像我们的那个树啊
04:16 以及我们远处的那些啊
04:17 建筑本身都是有很多的锯齿啊
04:20 对于一般的 PPR 的游戏来说
04:22 它的同频的一个边缘像素的占比
04:24 大概在 1%到 2%左右啊
04:26 对于一个 NP 啊 P 啊 NPR 的游戏
04:28 或者说二次元游戏
04:29 像去年的 UOD 救人统计过啊
04:31 某一款比较知名的二次元游戏
04:33 它的同频的边缘像素的占比
04:35 大概有 4%到 5%啊
04:37 按我们游戏来说可能会更高啊
04:39 所以我们的 A 可能会更加的很难做啊
04:42 所以我们会第一个讲我们的 A
04:47 啊那 A 的分享的话主要分几个点来讲啊
04:51 第一个就是讲我们 A 的一个
04:52 基本的一个渲染流程
04:54 第二个就是讲我们的一些关于鬼影啊
04:56 关于闪烁的一些优化啊
04:57 第三个是关于我们啊
04:59 在做一些更细节的效果优化的时候
05:00 是怎么做的啊
05:02 最后呢会简单介绍一下
05:03 我们那个 TAU 的 U 是怎么实现的
05:06 呃
05:06 呃这里有一个问题
05:07 就是我不会去介绍我们 ta 的
05:10 一般的一个算法流程
05:11 我就假定大家都是知道是怎么做的
05:14 所以我就直接就进入正题
05:16 直接讲怎么优化
05:19 啊
05:20 第一个介绍是我们的 ta 的 pass 和那个 U1
05:23 默认的 mobile ta 的 pass 的一个区别啊
05:26 这里是 U14 啊
05:27 U15 的话它是有一套 PC 的
05:30 那个 TA 跟我们的呃
05:31 可能整个的那个流程可能会有差异
05:34 会更大一些啊
05:35 可以看到左侧呢是那个啊
05:37 是由于默认的 TA 的 pass 啊
05:40 我们的右侧是我们的一个 pass 啊
05:42 从结构上来说呢
05:43 可能看不出太多的一些变化
05:45 就是我们加了一个 vast buffer 的一个 pass
05:48 然后 ta 的 pass 呢变成一个 TAU 的 pass 啊
05:51 但实际上在内部的实现呢会差异会比较大啊
05:55 我们加了一个 velocity pass
05:56 也就是因为我们需要对角色做处理
05:58 所做的一些额外的一个数据准备啊
06:00 另外啊 t a pass 放在了那个 bloom 和 TOMMAP 之后呢
06:05 它会产生一些问题
06:06 就是比如说 bloom 会导致他那个啊那些锯齿啊
06:09 和那些闪烁会被放大
06:11 但是因为现在的原因
06:12 我们最终还是选择了把它放到后面啊
06:14 当然我们有些手段可以把他一些问题给处理掉
06:20 啊第一个就是讲一下我们的一个呃鬼影
06:24 一般的鬼影问题的一个优化的方式啊
06:25 这个方式跟跟传统的方式没什么区别
06:28 也就是走的历史像素一个 clamp 的一个算法啊
06:31 那第一个就是我们的采样的一个 color 的选择
06:34 他各种选择呢在 PC 上呢是 33 的了
06:37 但是在那个手机上呢
06:38 我们是采用了一个十字星的一个采样
06:40 就是五个采样点啊
06:41 第二个就是关于那个啊历史上述的一个 BBOX 的
06:45 一个是一个计算啊
06:46 这也有三种算法
06:47 我们最后呢在手机上选的是 ABB
06:49 也是最廉价的一个方式
06:51 但它效果呢也会要略差一点啊
06:53 最后一个呢就是关于那个 color space 的一个选择
06:56 color space 的选择呢这一块呢
06:58 因为那个人也是对那个亮度
07:00 会对颜色会更加敏感
07:02 所以一般来说都会选择用用亮度
07:04 或者用把它颜色转换到 YCOCG 这个空间
07:07 去做一些那个历史像素的一个 clamp
07:09 呃
07:10 在这里呢我们是同时实现了这三种
07:12 三种三种分模式
07:13 然后呃我们会在低配机上会选一下
07:16 RGB 的一个颜色空间来做
07:18 但是可能在一些高配上面
07:19 可能会选择 YCOCG 来做啊
07:21 虽然说 YCOCG
07:22 单个单个像素的转换成本不是很高
07:25 但是它对于我们采用五个像素
07:27 或刚刚像素的时候
07:28 它的采样的啊成本会变得比较高
07:33 啊第二个就是啊 vs buffer 的一个介绍了
07:37 因为只有那个历史像素的 CP 呢
07:38 它其实是解决不了那个角色啊
07:41 或者说一些带其他的顶点动画
07:43 带谷歌动画的这一种模型呢
07:45 他的那个啊那个鬼影的问题的
07:47 因为它的运动轨迹是跟那个相机没有关系的啊
07:51 这是我们的一个 verse buffer 的一个呃结构
07:54 就是大概分为两部分
07:56 第一部分就是关于我们的一个速度
07:58 速度就是一个编码到了二二十四位的一个
08:02 另外呢还会有一个 character mask
08:04 他是专门记录说这个东西
08:06 是不是角色的这个像素啊
08:08 这个是因为在这个角色在做那个这个时候
08:10 需要非常精确的一个判断
08:13 是他是不是角色
08:14 这样就更不容易产生一些鬼影和一些染色的
08:17 一个问题
08:21 啊大家可以看看这个 buffer 看看有没有什么问题
08:30 啊这里啊
08:31 下一页就是就是这个就是讲的是我们的 vs buffer
08:33 其实可以看得到他
08:34 那个因为我们没有把那个勾边
08:37 这个 pass 渲染那个 voice buffer
08:39 所以它会导致说发展角色上有很多的黑边啊
08:42 这黑边的话
08:43 那他就会被因为我们的是凯尔特 mask
08:45 会判断他是不是角色的像素
08:47 这就会导致说我们在真正做 ta 的时候
08:49 会会判定他是不是一个啊角色的像素
08:52 这就会导致一些问题啊
08:54 为什么我会这么做
08:55 其实主要也是因为性能的问题
08:57 在移动端的话啊
08:58 如果说我们要选一个角色
09:00 对卡炫来说
09:01 他至少要选五六遍以上的
09:03 大家可以看到我这里列了一下啊
09:04 base pass 可能要渲染两遍
09:06 然后呢你的那个 velocity bus 可能要渲染两遍
09:09 然后你的阴影可能要渲染一遍
09:10 然后你的如果你要做一些类似 OIT 啊
09:13 或者是或者说像一些呃奇怪的
09:15 其他的一些像类似于呃勾边边缘光啊
09:17 这种效果
09:18 可能还需要渲染一个 custom 的一个 DEX
09:21 dex pass 啊
09:22 然后蒙皮的话就更夸张了
09:24 因为如果你要算那个 volt pass 的时候呢
09:27 你可能你需要每一次的渲染都需要蒙皮两次
09:31 因为它需要上一帧的位置和当前帧的位置
09:33 才能够得到一个呃那个它的速度
09:37 所以我们最终选择
09:38 其实实际上是是把它给去掉了的
09:41 就可以看啊
09:42 下一页就可以看看
09:43 大家看个视频效果
09:43 就是能看到我们去掉了 VC8P 之后呢
09:46 它会导致我们的角色边缘会闪的比较厉害
09:53 啊不知道看不看得清
10:08 大家可以看到一个头发啊
10:10 包括那个他的高边的边缘啊
10:12 然后内部的边缘
10:13 像衣服的边缘都会闪的比较厉害
10:18 然后我们再来看看我们 ta 的目标吧
10:21 然后又因为出了这个问题之后
10:22 我们总是要重新去想一想
10:24 我们要怎么应该怎么做
10:25 第一个就是说我们还是不想要 ghost
10:27 第二个呢我们需要我们的性能还是足够好的
10:29 因为我们要适配手机啊
10:31 第三个呢
10:32 就是我们最好是不要出现刚才说的那种闪烁
10:35 或者说尽可能的减少它
10:36 让它啊至少输出频率会低一些
10:39 或者说基本上我们感觉不到
10:45 啊然后这个解决方案呢其实也相对比较简单
10:49 就是我们操作操作方式比较简单
10:50 因为第一个就是像不需要告诉他这个事情呢
10:52 我们只需要不需要做什么操作就好了
10:54 因为我们现在本来那些边缘像素
10:57 就踩不到历史像素
10:58 所以它就是本身就不会产生 ghost
11:00 第二个呢我们需要性能要好
11:02 所以我们是坚持
11:03 我们是不去做那个 VC 发布的一个呃
11:06 那勾边的渲染
11:07 当然我们除了这个之外
11:08 还做了一些其他的优化啊
11:09 优化后面会做一个非常简单的介绍
11:11 就不会详细去讲了
11:13 第三个就是啊
11:14 要不现实不出现这个闪烁的话
11:16 那其实有一些方案可以做
11:18 就比如说我们尝试了用那个啊图像空间的处理
11:21 就是我们比如说做了一个低通滤波啊
11:24 低通滤波的话
11:24 那它就可以减少这些那个像素的
11:26 这些闪烁的问题啊
11:30 因为我们刚才在做那个历史像素 clamp 的时候
11:33 就已经采样过一个十字星周围的像素信息
11:35 这时候我们可以从这些采样
11:37 然而这个采样呢
11:38 其实就已经能够节省这部分的带宽
11:41 这是后面可以看一下我们的一个呃处理的效果
11:45 我们常用的一个低通滤波呢
11:47 比如说你用一个 boss fire 都是可以做的
11:52 啊这是我们处理之后的一个效果
12:07 啊然后这个想说的问题处理呢
12:09 也引发了我们对 ta 的一些别的思考
12:11 就比如说抛开 ta 的一个基本原理不说的话
12:14 只是单纯的看 ta 算法的实现
12:16 它其实就是呃有两个问题
12:18 第一个是如果说到历史真的权重比较高
12:20 那就比较容易产生鬼影啊
12:23 如果他历史真的权重很低
12:25 或者基本没有的时候呢
12:26 他就很容易产生闪烁啊
12:28 所以呢因为这针对这个问题
12:30 我们有些新的想法
12:31 我最后我们也把它给实现出来了
12:35 啊这样的
12:36 第一个就是说
12:36 我们尝试着把静态的像素和动态像素分开处理
12:40 我们引入了动动静了两台两套权重系统
12:43 然后呢
12:44 最终权重是根据 VACY 值的大小进行差值的
12:47 像像素的运动速度越快
12:49 它的当前真的那个权重就会越高
12:52 相反的如果运动速度越慢
12:54 那它的当前真的那个呃
12:55 它的它的当前真的权重就会越小
12:58 然后它整个物体就会变得更加的稳定啊
13:02 这是 P 上有一个简单的公式啊
13:05 这两个权重都是可以配置的
13:10 啊
13:11 第二个尝试呢就是我们引入了一套啊
13:13 图像的一个锐化算法
13:14 这个算法主要是为了处理动态物体的
13:17 这个动态的像素的啊
13:19 比如说我们选择简单的一个 unsharp mask
13:21 river 算法都可以啊
13:23 这时候 unsharp mask 算法它有个好处
13:25 就是它也是一个实质性的一个采样
13:27 所以我们仍然可以重用
13:28 我们之前的一个采样数据
13:37 啊最后是介绍一下我们 TAU 的 U 的部分啊
13:40 U 的部分呢其实没有太多的一个创新
13:44 所以就做一个简单介绍啊
13:46 这个因为一般来说在做图像做啊
13:49 上采样的时候呢
13:50 他考虑的是啊目标像素到原像素的距离
13:54 来做一个权重的差值
13:55 因为很多时候放大的时候
13:57 它的图像本身可能找不到原像素了
13:59 所以他算是个距离
14:00 根据距离来算权重
14:01 最后根据权重来做差值呃
14:03 但是呢对于呃呃后面新的一些算法
14:06 就比如像 FS2 的话的话
14:08 他们其实除了考虑那个像素的距离之外
14:10 它还会考虑原像素本身的一
14:12 些边缘的一个情况啊
14:14 这个算法呢这这两部分我们都是有实现的
14:17 然后这里呢就写了三个那个采样那个滤波器的
14:20 选滤波器的一个函数
14:22 包括有图像啊
14:23 这图像呢呃像那个 LAZS 就是 LAZS2
14:26 就是那个 F3 用了一个函数
14:29 然后拉 S2 的话
14:31 FS 它的一个精髓
14:32 实际上是实现了一套那个多项式的一个
14:34 一个逼近
14:35 最终我们也是用了多项式逼近去做的
14:37 然后我们也实现了一个双线性采样的
14:39 一个上采样
14:40 可能在不同的机器上会开开不同的一些
14:42 上采样的一个算法
14:47 啊这是我们 ta 的一个数据的一个对比
14:50 就是总结一下
14:52 就是我们 ta 实际上是一个混合方案
14:53 就是我们既实现了一个比较经典的一个
14:55 ta 的一个算法
14:56 同时呢又融合了一些图像处理的一些方
14:59 式和方法
14:59 然后呢又针对不同的像素的特征
15:01 做了一些像素的混合处理啊
15:03 和弱化处理啊等等啊
15:05 这些优化有些是不光用在 mobile 上面
15:07 也用到了 PC 和主机上面的
15:09 然后呢我们测试数据大概是 865
15:11 上面的话
15:12 如果只开 TAA 的话
15:13 大概是 1.1ms
15:15 然后如果说是开 TAU 的话
15:17 大概是 1.5ms
15:25 第二部分的话就是明朝的 one pass default
15:27 管线的一个姐姐啊
15:29 主要是想分享我们查了两个比较大的坑啊
15:32 相信业界很多人做的时候都会碰到这个问题
15:35 我们用的是 U14
15:37 大家知道有些问题是 U4 独有的
15:41 啊第一个就是相当简单
15:43 介绍一下我们的整个 one pass 的一个实现
15:45 就是所谓的 one pass
15:46 是说我们的这张图的左图里面
15:48 黄色的边框里包含了所有 pass
15:50 就是在一个音节 pass 里面实现的
15:53 然后我们的 lighten 的拆分呢是走 cluster 去做的
15:57 然后我们材质呢主要是分为三类
15:59 就是啊卡片的材质
16:01 然后 NPR 的植被的材质和场景的
16:03 其他的材质是 P2 的啊
16:05 明朝虽然说是告诉原游戏
16:07 但是场景大部分的材质都是 PPR 的
16:09 然后我们的材质区分
16:11 是通过那个三索 mask 去做的
16:14 我们支持的 API 呢是哪个
16:16 我们加加 3.2
16:17 然后 metal2 和三
16:18 然后 ban one pass 实现
16:21 那都是基于 on cheap memory 去做的
16:23 这一部分的话
16:24 因为有很多的分享
16:25 所以我就不做细节的介绍了
16:32 啊介绍一下我们的 J8 号的结构
16:33 我们第一版的时间里用到了三张 J8F
16:36 加上一张 SCOLOR
16:37 然后再加上一个 depth buffer
16:40 所以我们应该是四张的 G8
16:41 或加上一个 depth
16:42 然后我们通过 depth
16:44 是通过 dex fish 去获取深度信息的啊
16:47 三种材质里面的新 color 传的都是自发光计划
16:49 不 A 呢存的都是法线
16:51 然后拉 fin 和一个通道的卡片信息啊
16:53 NFON 是用来做那个啊云层投影用的
16:57 然后 G8 部 C 里存的是 base color 和 L 的信息啊
17:01 G8PB 的话是每种材质是都不太一样
17:03 是一些比较特化的一些信息
17:08 大家看一下图
17:09 图上有详细的介绍
17:13 好啊这是我们实现完了之后测试的一个结果
17:16 就是比较比较意外
17:17 就是发现一个比较大的坑
17:19 就是实现完之后呢
17:20 在那个 arm 的 money GPU 上测试的时候就发现呃
17:24 三个灯光 pass 的指令速度非常的高
17:26 比相对于那个苹果和高通来说高了很多
17:30 然后我们通过 streamline 的一个分析之后发现
17:32 其实是 LPK 失效了
17:34 这三个灯光 pass 的 f pk 就只有 0.01 兆啊
17:38 这个图上面应该有
17:39 但是可能不一定看得很清楚
17:47 啊然后又进一步的测试
17:48 最后其实发现是 dave space 的问题
17:50 也就是说啊
17:51 不管是你用了什么用了啊
17:54 在什么地方用的 DESPSS
17:56 也不管你是啊 one pass default
17:58 或者说你是其他的功能里面用了这个这个功能
18:00 那它都会导致那个 OPK 失效啊
18:03 这里有个对比数据
18:04 大家可以看到那个在关闭 double space 之后呢
18:08 他那个的 MPK 它的数数量大概有 1.2 兆
18:12 如果开了的话
18:13 那就只有 0.01 兆
18:14 两只相差了 100 多倍
18:16 而这个数据我们最后也给去找 arm 的同学
18:19 去确认过
18:20 他们说在最新的 arm 的驱动层面
18:23 可能解决这些问题
18:24 也就是说 93 年级以后
18:25 有可能这个问题是没有了
18:30 啊解决这个问题的话
18:32 那就不能用 DEFISH
18:33 但是不用 defeat 的话
18:35 我们 G8 号又是不够用的
18:36 所以啊 JPU 不够用
18:38 是说像 PS 它就只有 128 位啊
18:41 虽然说 arm 的文档里面
18:43 可能很多时候
18:43 大家可以看到
18:44 256 位及
18:45 512 位及更高的一些位数
18:48 但实际上它真正可用的
18:49 我们跟所有机上测试都只有 88 位
18:53 但是我们又不想在 arm 上损损失我们的画质
18:56 所以我们需要做的是另外一个比较艰难
18:58 但是也更正确的一条路吧
19:03 啊这是我们最重的一个方案
19:05 就是我们其实是最后是一条混合管线
19:07 就是 one pass default
19:09 加上一个 FORWORD
19:10 一个卡通渲染
19:11 再加上一个 G8F 重新进行编码
19:13 就把原来的 depth 编码到了那个啊 JPER 里面去
19:22 啊
19:22 这是我们修改之后的一个 G 发货的一个结构啊
19:25 大家可以看一下
19:26 因为呃那个卡通渲染这一块
19:29 已经放到前向渲染去做了
19:30 所以他的 G8 核就没有必要再存他的信息了
19:33 所以我们就 J8F 就有三种模式
19:35 变成了两种模式
19:36 第二呢就是因为我们之前无论是在 PPR 里
19:39 或者说 NPR 的那个植被里面
19:42 其实都存了一些额外的一些
19:43 那个卡片的一些信息
19:44 这些信息都可以去掉了
19:57 啊这是我们就是修改的 pass 的一个结构
20:00 就是啊第一步想的就是说
20:02 如果说我们把那个角色变成一个前向渲染的话
20:06 那么我是不是额外加一个 ford pass 就可以了啊
20:09 但实际上后面经过考虑其实是不大行的
20:12 因为他要处理的问题实在太多了
20:13 就像我们这个图里能看到的
20:15 就是我们其实在 lighting pass 之后要处理的东西很多
20:18 在 base pass 之后处理的东西也很多
20:20 其实我们如果把那个角色放在了那个呃
20:24 Transparency
20:25 就是半透之后的话
20:26 那会导致两个比较大的问题
20:28 第一个就是我们需要把 deco light function
20:30 然后 water 呃
20:32 Fog
20:33 然后 TRANSGENCY 等等
20:34 这些所有的信息都在那个 for the past 里处理一遍
20:37 这样要不然的话他就会出错
20:39 要么就是有排序问题
20:40 要么就是有效果的问题
20:41 第二呢就是如果这样去做的话
20:43 它会导致我们打断我们的 one pass
20:45 就是等于我们要多做一个 pass 来做这些事
20:47 那那做这个事情的话
20:49 就会导致我们的贷款也会增加比较多
20:51 我们的优化就等于白干了
20:55 啊
20:56 这是我们最终的一个实现了一个 pass 的一个结构
20:58 这是我们最后把它放到了那个 lighting pass 后面
21:02 这样我们要处理的啊
21:03 问题就变简单了
21:04 就只有 DECO 和那个 light function 需要处理
21:07 然后 water fog 和那个半透了的话
21:10 那我们就直接在里面做就好了啊
21:12 这个值这一部分的修改实际上是非常大的
21:15 整个试管线基本上等于重新写了一遍啊
21:17 流程时间也很长
21:19 但是细节的话我这里就不做分享
21:21 因为时间啊有限
21:22 这个优化效果是非常明显的啊
21:25 我们大概在马里的 GPU 去做测试
21:27 平均有五到 6℃ 的一个下降
21:29 然后 GPU 时钟频率大概下降有 25%左右
21:32 所以这个我觉得大家是值得去做的
21:37 啊另外一个就是我们在 default 草的第二个坑啊
21:39 这个坑比较小啊
21:41 但是可能比较容易比较难翻发现
21:43 而是在高通基本上我们做 one pass multipass
21:46 一个带宽的对比的时候就发现啊
21:49 读的带宽呢其实它的节省还挺多的
21:52 但是那个写的带宽基本上没有什么节省
21:55 就是感觉没有优势
21:57 然后后面也查了很久
21:58 然后最后发现实际上是引擎的 r hr 实现
22:01 有一个小的 bug 导致的啊
22:02 这是由于 4.26 和 4.7 都有的问题
22:05 但 U15 之后呢就已经没有这个问题了
22:08 因为它这里是指啊注意看这个代码
22:11 其实我就把这一行给标出来
22:12 就是一个黄色标出来的
22:14 它只对了那个新 color 和 DEX 生生效
22:17 就是如果你是丢掉 discard 这这张 RT 的话
22:21 他会把 G8 分成三张都 reserve 出来
22:26 啊就是后面我们修改了一个代码啊
22:28 大概思路值也比较简单
22:30 就是你所有的 RT
22:31 跟你 1DEX 都是可以把 discard 掉的
22:40 啊最后是也是一个测试性能测试数据
22:43 这个测试数据的话
22:44 就是我们最后是用 one pass 和 mi pass
22:47 带宽的一个测试结果啊
22:50 这个实际上这个结果呢比我们预想的要啊
22:53 要是有点惊讶的
22:54 就是按理说我们觉得应该会节省更多
22:56 就按照理论上来计算的话
22:58 我们实际上应该可以节省 1.8G 左右的带宽
23:00 但实际上我们大概只能够节省
23:02 830 兆左右啊
23:03 这个是因为那个 ARDUINO 和那个玛丽的 GPU
23:07 他们其实都会做 RT 的压缩
23:08 这个压缩的效率其实还是相当惊人的啊
23:12 大家注意一下
23:12 这个数据实际上比较有意思的
23:14 就是读的带宽都能节省在 30%以上
23:16 但是写的带宽节省只有 10%
23:18 到 15%左右
23:22 啊我们单纯的带宽消耗也是非常的少
23:24 大家可以看到实际上就大概只有一点几
23:27 1.2G 到 1.3G 之间还不到 1.4G
23:30 这是我们一帧的一个带宽啊
23:33 不说错不利
23:34 真是一秒钟的带宽
23:35 60 我们是 60 帧的游戏
23:39 啊接下来就是最后一个方案了
23:42 就是竖的一个双单的方案
23:43 我讲的很快啊
23:48 啊输的方案呢就是在介绍这个方案之前
23:50 我会先简单介绍一下
23:51 我们多平台的一个适配的一个策略
23:53 是怎么样子的啊
23:55 然后呢再会介绍我们数大概是怎么去做多
23:57 多平台的适配
23:58 包括怎么去做一些方案的
24:04 啊
24:04 这是我们的一个多平台适配的
24:05 一个基本的一个框架
24:06 就是第一部分的想法就比较简单
24:09 就是我们多平台只是当做一个平台来处理的啊
24:12 这个思路想想其实也没什么问题
24:14 就是比如说我们的 PC 的高配就等于 PS5
24:17 然后我们 PC 的中配啊
24:19 PS 的低啊
24:20 PC 的低配呢比 P4 要高一点
24:22 然后呢 P4 呢又比呢 p mobile 的高配要高一点
24:26 因为对平台来说
24:27 实际上影响它的因素就只有内存计算能力
24:30 计算能力包含你 CPU 和 GPU 的
24:32 然后还有 IO 的性能
24:33 然后你的功耗的一个影响啊
24:36 对于发行来说可能还多一条
24:37 就是你的包体的大小
24:38 那除此之外
24:39 其实没有什么东西会影响我们去做什么
24:41 多平台适配的啊
24:43 所以我们的主要方案呢
24:44 也也一般来说也分为三个层面去做处理
24:47 就是我们在打包的时候去做一些处理
24:49 然后我们在加载的时候去做一些处理
24:52 以及我们在运行时去做一些处理啊
24:54 所以后面列了一些主要方案
24:55 就是分布在这三个不同的阶段去做的
24:58 就比如说我们在打包的时候
24:59 可以区分一些平台相关性
25:01 然后也可以做一些 i d BIOS
25:03 比如 BIOS 啊等等
25:05 我们也可以在加载的时候
25:06 比如说加载更少的数据
25:08 或者是把游戏平台相关的东西给过滤掉啊
25:11 那我们也可以在运行时去做一些动态的
25:13 比如说像那个 ID 切换了个呃那个缩放啊等等
25:18 但是这里做多平台呢有一个坑
25:20 大家可能要注意到
25:21 就是你的钢胚类数据
25:23 一定是需要跟引擎的显示啊
25:25 以及或者音视频这些数据的分辨率啊
25:27 码率啊都是要分开的
25:29 就比如说你把 IOD 做了 BIOS 之后的话
25:31 你就会发现碰撞可能对不上了
25:33 你贴地就就完蛋了
25:35 你这脚就踩不到地上了啊
25:36 就类似的这种问题
25:37 除了呃碰撞之外
25:38 还有其他的包括寻路啊啊一些物理数据啊
25:41 都会有些类似的问题
25:45 啊还有一个好处
25:47 就是因为我们这个游戏呢是一个 ST
25:49 所以我们只关注三五十米之内的这些
25:53 跟 play 的数据
25:53 而不会关注很远
25:54 就比如你做的是一款 FPS 游戏的话
25:57 那你可能会需要关注到啊
25:59 你的就比如说你可能 100 多米啊
26:01 200 米之外的这些物体
26:02 因为它需要开镜
26:03 开镜之后呢
26:04 他需要他的物理精度是保持的
26:11 啊这是我们的数的一个通用的一个方案
26:13 的一个简介
26:14 就是按照平台来分
26:16 首先呢 PC 和主机来说
26:18 我们的近景都是模型数
26:19 然后中景呢是 b boy 的数
26:21 远景呢是 import 数啊
26:24 对手机来说呢
26:25 我们的近景呢就已经是标高了数了啊
26:27 中远景呢是 impulse 的数
26:33 啊第一个就简单介绍一下我们的呃
26:36 标波的数是怎么实现的
26:38 就我们标标的数量实现
26:39 基本思路是把原来插片数的每一
26:42 每一层树叶都面向相机的
26:44 变成一个标 word 来替代啊
26:46 这里左侧呢就是那个标波的数
26:49 右侧呢是啊
26:50 卖这 man 是插插插票数啊
26:52 然后左图是一个效果对比
26:54 右图呢是一个我们大概三角形的一个一
26:57 一个对比
26:58 可以看到我们的呃统计数据是标包的数
27:01 大概只要 30%到 40%的一个
27:04 面片的一个占用
27:05 就可以达到我们卖树的基本的一个效果的还原
27:16 啊这是一个比较详细的一个效果的视频
27:19 就是我们啊左侧是标包的数
27:21 右侧呢是插片数
27:23 我们在相机下面就是前后左右上下转动相机
27:26 看看效果的对比是什么样子的
27:28 大家可以看到效果其实还是可以的
27:38 但是 b boy 有他的问题啊
27:40 这大家看到了阴影是有问题的
27:43 可以看到了
27:44 就是因为比较薄弱的时候是面向相机的
27:46 那它一转动相机的时候
27:47 阴影就会跟着转动
27:48 这个看起来是不能接受的
27:53 嗯但这个解决起来也很简单
27:55 就是把那个渲染阴影的时候
27:58 让那个标包的面向光源就好了
28:00 没有必要去面向相机
28:05 啊接下来呢就是介绍我们的 import 数啊
28:08 一个比一个比较常见的错误
28:10 是认为 import 数就是一个比较薄的啊
28:12 比较 input 和标 boy 其实没啥关系
28:16 import 树的基本思路是围绕模型放一出
28:18 现相机去拍这棵树
28:20 然后记录下书的一些基本的渲染信息
28:22 就比如说类似于一个 mini 的 G8 分
28:24 在渲染的时候呢
28:25 再通过相机的方向去采一些
28:27 最接近当前相机方向的
28:29 那些离线渲染出来的信息呢
28:30 做一些信息的合成
28:32 最终呢生成当前相机架
28:33 它应该出现的那个样子啊
28:35 这是我们用 POS 数的一个设计目标
28:37 大家可以看一下
28:38 除了那个着色和形态上
28:40 我希望能够还原之外呢
28:42 我们还希望它能够支持各式各样的投影
28:44 就比如说他自己可以投影到场景里面啊
28:47 然后他也可以接受场景的投影啊
28:49 它有个支持云层的投影啊等等
28:51 然后同时我们也希望它内存占用要足够少
28:54 除了渲染效率也好之外
28:59 啊这是我们标就是 import 数的
29:01 刚才说的那个离散渲染的那个信息
29:03 就那个 buffer 的一个组成
29:04 这八份是一张 32 位的一个纹理
29:07 然后 RG 通道存的是 NORA 信息
29:10 然后 B 通道存的是一个 local 的一个深度的
29:12 offset 的信息
29:14 然后呢
29:14 那个 A 通道传呢是一个呃 defuse 的灰度信息
29:18 并且呢
29:18 还存了一些用于区分树叶和树干的一个信息
29:21 区分树叶
29:22 树干是为了在着色的时候
29:23 他们可能有不同的一个角色模型
29:25 然后那个本身的 DEFS 那个灰度信息呢
29:28 可能可以用一些 AO 的一些校正
29:34 啊这个这 1PPT 其实内容很多
29:36 但是我讲的可能会比较少一点啊
29:39 就是我们为了实现它内存占用比较少
29:41 然后又能够让他出货比较少
29:42 所以我们就啊扩展了 UV 的默认的 TESORRY
29:46 我们把它做成一个动态 test r
29:48 也就是说我们的 test way 是一个呃创建
29:50 会创建一个比较小的
29:51 但是我们会动态去更新它的每一个 slice
29:53 同时我们支持 streaming
29:55 我们可以需要的时候
29:56 按需加载一些需要的 slice 进来
30:00 啊这样的话我们在这个条件下
30:02 我们支持的数量是非常多的
30:08 啊这个是那个关于 depth 还原这一部分的啊
30:11 因为那个对于要做阴影的话
30:13 其实最重要的是怎么去还原它的 depth
30:15 因为我们刚才在那个 mp4spark 里面
30:17 已经存了那个 local depth
30:19 所以这时候呢我只需要把那个 rector
30:22 就是刚才在那个相机空间站的那个举行
30:24 他的一个深度
30:25 加上他原来的那个深度
30:27 这个偏移就可以还原出来
30:28 它的在 view 空间的这一个啊
30:31 接近它的原始信息的一个 demo 的一个预估
30:35 最后再乘一个那个 project 那个矩阵的话
30:38 就可以得到一个投影后的一个深度了
30:40 然后投影后的深度你想转换成 depth device z 呢
30:43 或者说 ALENAZ 都是可以的
30:45 最后有了这个 Z 之后
30:47 其实在后面再做
30:48 无论是接收投影啊
30:49 投影啊
30:50 或者说是你做 DAO 啊
30:51 做作物啊
30:52 都其实是一回事啊
30:54 就跟普通的模型没有什么区别
30:55 包括主光照计算也是一样的
31:03 哦这是一个呃我们阴影的一个展示效果
31:06 可以看到红框里标的都是我们的 input 数
31:08 在场景中的投影啊
31:10 包括他们那些自投影
31:11 这个树离我们的角色的距离
31:13 大概是在 300 多米以上啊
31:16 可以看到应该没有很明显的一个瑕疵
31:24 啊这是一个那个和那个 mesh 数的一个对比
31:27 就是我模型数和 input 的对比
31:29 左侧呢是关了 post
31:31 只有模型数的时候的一个效果
31:33 右侧呢是卡拉 post
31:35 和和模型数同时共存的时候的一个效果啊
31:38 大家可以稍微观察一下
31:39 可能在光影上面会有一点点地方有些不一样
31:42 但是不是特别明显了
31:50 啊这是接上一张图的
31:52 就是我们看看哪些树是 impulse 渲染出来的
31:54 如果来进一步让大家去区分这些数
31:56 这蓝色的部分就是我们的 input 数
31:59 然后那个绿色的那些树呢是真正的模型数啊
32:03 这部分呢他那个因为有一棵大的树
32:05 大家注意没有没有切没有切换
32:06 它是因为有一些很大的树
32:08 或者说它是一些 POI 的一些树
32:10 那它是而是可以允许他不切换的
32:16 啊最后我们大概的一个性能数据
32:18 50 种树木
32:19 3000 多棵树的实力
32:21 就是我们同时加载的时候啊
32:23 渲染的时候大概有 1000 多棵吧
32:24 然后有每一棵树呢大概有 300 多个
32:27 就两级 imposter buffer
32:28 312 个
32:30 import8 份
32:30 然后加起来
32:31 一共它的内存实际上就只有小于 15 兆
32:33 然后四个就扣就可以画出来
32:35 面数是小于 4 万的
32:37 然后 GPU 的一个耗时
32:39 这个消耗也是很小的
32:40 GPU 扣了大概是四兆以内
32:42 那就基本上能够满足我们对效果
32:44 核心的一个诉求
32:48 最后还有一些其他的一些优化
32:50 就是我们的标签的数和 import 数
32:52 都是直接嵌入到了数的 IOD 链里面去的
32:55 这样的话我们在做 IOD 切换的时候
32:57 没有什么额外的处理啊
32:58 另外就是我们的一些术士走 ISM 去啊
33:02 去去做的
33:03 因为它的模型素材近处还是需要去和平的
33:06 那这时候呢 SSM 是比较难切 LOD 的
33:09 因为它标那个包的包围盒会比较大
33:11 这时候我们做一些优化
33:13 就是我们啊选了一个 SM 中最大的那个那个物体
33:17 来做他的 ID 切换的一个一个配比
33:19 这样的话 IOD 切换也会比较快
33:25 好我的分享今天就到这
33:27 谢谢大家

## Content

目录：
![ ](image.png)
