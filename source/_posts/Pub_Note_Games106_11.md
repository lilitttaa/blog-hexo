---
title: Games106 11.着色器优化
category:
 - Game
sortValue: 014
---

## overview

![Alt text](image.png)

- shader 优化主要主要是偏代码优化的一些东西
- 主要分为手动优化和自动优化

我们先来说一下为什么要做优化？

![Alt text](image-1.png)

- 现在 3a 游戏或者大型游戏的 shader 越来越复杂，比如说像这样的一张材质的节点图展开过后的代码会变得非常巨大。
- 然后要对每个像素去运行这些代码就非常耗时。
- 所以加速这个部分的计算实际上就是加速游戏的整个绘制核心。

![Alt text](image-2.png)

- 从设备上来说，从 IPHONE640 到现在的 Vision Pro，分辨率已经涨了不止十倍
- 刷新率也在不停的涨，从最开始的 30HZ，60HZ，到现在的 Vision Pro 需要 90HZ，甚至有一些屏幕放 120HZ 去设置

## shader 优化

shader 优化也分为几种：

- 编译阶段优化
- 执行阶段优化

### 编译阶段优化

![Alt text](image-3.png)
![Alt text](image-4.png)

- 很短的一段代码，编译出来会是非常长的一段指令串
- 实际上，编译器把一些优化给做掉了

编译器的优化主要有这几大类，主要是在一些常量还有变量上面去做优化：
![Alt text](image-5.png)

- 比如这里的常量传播，编译器可以检测到这两个东西的相关性，直接把这个变量的赋值给拿掉。

![Alt text](image-6.png)

- 一些中间变量的折叠或删减

![Alt text](image-7.png)

- 复写传播主要是指把 A 复制到 B 的这样的一个渐进式传播过程，如果编译器可以检测到这个过程的话，也可以同样把它给消除掉

![Alt text](image-8.png)

- 检测到一些关系式是可以相互替代的

![Alt text](image-9.png)

![Alt text](image-10.png)

- 如果中间有非常复杂的变形，就不会展开了

这里需要额外提一下的是，编译期优化它不一定是稳定的，有时侯会不管，因此要养成良好的代码习惯。

### 执行阶段优化

真正可以人为操作的人为控制的，更多是在执行阶段的优化：

![Alt text](image-11.png)

- 代码级的优化：把一些复杂的操作简化掉，比如一些循环给干掉
- 算法级的优化：用不同的算法实现同一个事情，在复杂度上的优化
- 这个过程就是体现程序员的码力的时候
- 有时候优化是有损的，比如用一些近似算法，用 texture 替代一些计算。通常是直接由资深程序员分析出来。当然最不济的情况也可以跑一下然后去测它的一些指标。
- 借助性能分析工具分析哪些是 IO 瓶颈，哪些是迭代的瓶颈。
- 做这些优化的时候，通常是跟硬件高度相关的。我们得知道 GPU 有几级着色器缓冲，以及每级缓冲之间的代价等。

手动优化的基本准则：
![Alt text](image-12.png)

- 清晰代码所造成的寄存器消耗
  - VGPR 就是这个向量寄存器的容量，寄存器最好是少用，但是如果用的话，不要超出他的上限。
  - 这个是 AMD 的 Radeon Analyzer，变到编译器代码之后，它会动态的显示每一行代码所产生的寄存器消耗
  - 还有包括一些共享内存（LDS、shared memory），都是可以通过一些 profile 工具拿到的。
  - 像 LDS、shared memory 这种慢一些的缓存拿了过后还要到显存去造一些临时寄存器使用，这种情况应该尽量避免。
- 降低 IO
  - 尤其是 CPU 内存到显存的 IO，这个是非常需要关注的。
  - 相邻的 thread 或者相邻的 pixel，如果在一个 block 里去读那个 memory 的时候，读显存还有读内存的时候，最好是一整块一整块来读。
  - 如果是交叉读，中间有一个 stride，一般是要拼到 128 给 dest stride。 
  - 如果是完全随机的读写，这个基本上会把你这个整个程序卡崩掉。
- 减少指令循环
  - 复杂 OP 基本都是用一些特殊的一些指令集，特殊的计算单元去实现的。并不能用那种简单的 ALU 去做，所以应该尽量避免。
  - 如果要用的话，在绘制里边有很多近似的 sin、cos 这样的数值算法。就是用查表，把常用的数值范围取出来，如果数值精度要求不高的话，这些都是足够的。如果需要非常高的精度，可以去网上找一些 tips。

做优化的时候常用的一些策略：
![Alt text](image-13.png)

- 把一些不太高频的东西从 fragment shader 里面移到 vertex shader 里面去，对画质影响较小。
- 预计算：
  - 比如 noise 用数值方法计算，很耗时，可以直接把这些东西生存好，然后直接做采样。
  - ambient occlusion，跟模型自身相关性比较大，可以近似的看作是静态的东西，先预计算下来。
  - 一些整个场景的光照结果都可以预计算，然后烘培成一张纹理，直接读取颜色。尤其是在一些背景和静态光源上面。

![Alt text](image-14.png)
另外呢还有一个措施的

刚好读刚才那个用保存数算是反过来的

有时候是我们需要去用计算机保存的

比如像这个 PBR 模型啊

呃有时候是需要去用这个 propane 和 NDOTV

去采样一个 LET 纹理

然后这样子的话会多一个多一次保存

但是反过来呢

就是说嗯

其实也可以用一些算式的方式去数值函数

去逼近这个东西啊

就像右边这样

这些就可以直接计算出这个呃卡 table 看情况

如果是说我们需要减小计算

然后这个访存带宽还比较宽裕的话

其实可以反过来就是比较灵活的事情

还有一些

### 00:16:06,50

![00-16-06](tmp/00-16-06.jpg)

常数代替一些地方

但是对正确的说法

就是说这个数值给到编译器

会帮你去把它处理掉

提前弄好啊

然后你不要去给太多的这些影视的

如果是这些数值是确定的

不要服太多的这个 floating

不要自作多太多的变量

这个东西不好

然后的话像一些啊派出派 half

half pie 这种常用的东西

直接把它啊 DEFI 好不学

不要在月经时候去计算这些啊

刚才这些东西其实跟那个编译器优化

只是游戏相关的编译器嘛

有时候能兑换

有时候不能优化到

我们还是尽量养成一些良好的代码习惯

另外再下一个就是一些低精度数

像这个编译器里面啊

SHADER 里面 float half 这些都是可以支持的

像高精度的

然后用到这些像 HDR

还有一些 UV 啊

还有一些数值

你如果确定可控的话

那半精度其实也够啊

那这个系的话像一些要怎样颜色的话

用 fix 也够了

主要是在一些 mobile device 上面会比较敏感啊

剩下几个 tip

### 00:17:27,50

![00-17-27](tmp/00-17-27.jpg)

一个是右键进行标量计算

就是像左边这个地方嘛

是先把这个有两个标量

一个向量

然后向量乘标量

我们先把标量全部乘上来

再乘向量

那最后面的话其实这个只是有一个三个乘法

但是如果反过来

我们先把一个标量和向量乘上了

展开了就变成一个三维

这会产生一个三个乘法

然后这个地方再乘一次

又会变成三个乘法

这个计算量加倍

所以的话优先去能够合并的

把一些维度比较低的计算合并掉啊

这个是一个技巧

然后分支分支是需要避免的

因为我们的 GPU 其实是那个 FI 啊

MD 就是 single instruction

Artical data

就是说啊他的指令控制器其实是非常少的

机动单点比较多啊

是这样的话呢

呃可能是几个 reg

32 个 spread 啊

一个直线

一个指令流程

如果 16 流程里面产生了分支

像这个一等于一啊

叉叉叉这样的话

那就求他

其实你可以认为它分支里和分之外啊

两个东西它都分别执行了一遍

因为他只有一个指令串去避免这种情况呢

就是用一些啊并行化的一些 OP 去替代下的 if else

像这 if x 等于等于零

其实是可以纯粹的去使用一些数值的方法

就是 van equal

这个地方你可以看一下啊

这个其实不难理解

就算一个啊

sin x 减 Y 它如果相等的话

那就会反复返回一个零嘛

所以就可以直接用这种并行的一个东西

去替代掉

做法就是减少一些 20 的数量

所以从软件工程的角度呢

摔的不成功呢

刚才那个是会更干净

但是你在试用的时候

其实是又要把一些税的合并起来啊

不能用大税上面去降低他们之间的一些传输啊

减少 pass 的数量

这种都是一些

然后除了这种啊这技巧的

### 00:19:49,0

![00-19-49](tmp/00-19-49.jpg)

我们在上上期空气技巧其实是个人的修

为了看大家的修行

那更多的一些常用的

可以规范化的一些东西是层次细节

OK 我看有些问题分享点

这样就可以

意思是说呃 LDLD 的话一般就是一个原理

基本的原理

近大原材能有更多的模型

它远地方能更稀疏的模型

就是在 Mac 上

然后着色器其实也有同样的一个 LD

在近的地方我们用一个啊带有比较的一个 LD

就是他的代表他们更强和地图更复杂

但是远的地方可以用一个简化掉的

然后 D 啊一个水准

所以在我们真的好

这个地方应该是 max

你比如说像那个我们更具体一点的话

像非得上做一个层次

### 00:21:03,50

![00-21-03](tmp/00-21-03.jpg)

细节大概有什么样的呢

一个就是一个方向模型的迭代

比如说这个 LD0 啊

一二是最就持续可用不同的光照模型啊

去做同一个事情

GGX 是最复杂的计算

最真实的同时也会最慢

然后可以换成独立

从

然后再远一点的话呢

立风的话有一些 MICHAEL 啊

一些啊主表面散射一些特征

然后再远点就可能用啊一个 uniform 的一个采样

就只要有一个简单的颜色就做

### 00:21:40,0

![00-21-40](tmp/00-21-40.jpg)

甚至是说啊原地方的就用一些一计算的

### 00:21:43,50

![00-21-43](tmp/00-21-43.jpg)

可 computer 的一个颜色

这就行了

然后另一种 LD 的设置呢

就是说把这个我们最终能光大成在哪

拆分成不同的成分

然后去用这个层次

那个光的成分去做一个 LD 最近的地方啊

你可以认为是有一个

我们可以把所有的 component 都加上来

你把这 ACULAR 也加上

然后稍微远一点呢

SPECULAR 可以去掉

只留 DEBU

那这种是一种啊

还有带远一点的地方呢啊

可以把这个 intellect 这种东西都可以去掉

链接光这些东西都可以拿掉对

然后这个烘培烘培刚才也讲过了

就是把这些颜色提前放到这个啊

the text the texture 里面去

呃

然后的话因为你烘培弹的像一些集合

嗯嗯啊

那你就随着这个集合的 LD

自动的去做一个简化了

然后这个新的看 try 也可以有一些整理的心啊

他也可以有 LD 啊

去做这个 4.6

### 00:23:03,50

![00-23-03](tmp/00-23-03.jpg)

接下来

其他的可能更像个工程

投递一些商品进行学术

在公司上啊

首先是 motivation

### 00:23:29,50

![00-23-29](tmp/00-23-29.jpg)

就是这个手动优化

其实就是我们刚才讲他是一个非常惊艳性的

非常工整的一个东西

你这个程序员要知道怎么去调整那个代码啊

然后要知道怎么修改这个评估

这个修改或者代码的效果怎么样

这个也要经验

要怎么平衡质量和速度

所以也需要经验

那常常呢就是说不同的 FD 不停的 try 不同 TT

其实是比较枯燥和比较繁琐的一个过程

那所谓自动的话呢

### 00:23:58,50

![00-23-58](tmp/00-23-58.jpg)

就是我们把这个东西全部给自动化啊

要让计算机自动调整这个代码

计算机器自动评估这个代码在调整之后的质量

然后之后去自动去找这个质量和速度的平衡

把这个整个东西都自动化

### 00:24:16,50

![00-24-16](tmp/00-24-16.jpg)

那他整个框架的是这样的啊

就是说螺丝器进行优化

那首先我们的 input 是一个啊 SHADER

### 00:24:23,50

![00-24-23](tmp/00-24-23.jpg)

一个 shader code

一个着色器的一个 code

然后除了这个 code 之外呢

我们一般这个它我们需要优化的场景

Mesh

还有他的一些 permuniform gm

像风暴什么东西

其实也是需要作为这个中优化框架的一个输入

因为从原理上来说呢

这个水井扣会产生在它所产生的结果和 L

是跟场景和跟那个 parameter 相关的

然后这个格射器呢

### 00:24:55,0

![00-24-55](tmp/00-24-55.jpg)

他会去尝试产生不同的这个啊

优化后的一个代码

这个优化后的代码呢

他要去评估他们的一个质量

像这个啊通常的话会把它顺出来

这个最蠢的一个办法

但是也是一个智能效果最好的一个办法

然后我们要找他的一个潘尼托前沿

因为不同的视角

你看啊

我们如果画出来一个横坐标是它的一个误差

粽子表示一个时间

那我们要做一个时间和误差的平衡

那肯定是希望是在这个要么就是使用费用

要么就是这个啊艾尔之中

就是在这个叛逆多线上面

去找我们所需要的 LOD

或者是我们选择需要的一些优化的设置

有时候呢你也可以去培训

比如说像我们就是啊项目里面的话

可能会给到一个误差上限

就是说我们这个误差不能大点的值

那么点到了这个插上线之后

去找这个时间是 U 的一个点

那或者反过来给定了一个啊时间

大学我们去找这个补差最 low 的

这就是它实际的一个用法

然后对于不同的这些东西吧

像这个怎样去优化这个着色

可以产生一些啊它的一些 various

然后有各种各样的工作

怎么样去评估它的一些误差啊

嗯更好加速这个帕尼克现在寻找队友

又产生了另外一大类的工作

我们会后面会简单的去覆盖一下这些事情啊

### 00:26:39,50

![00-26-39](tmp/00-26-39.jpg)

这里这些东西呢啊

就构成了这两个方面的研究吧

就构成了这个呃

税的减速简化的一个主要的一些研究内容

然后我们再再来开开心一点啊

就是说这是一段文字器代码

就是给定了一段总是代码自动器简化

就是去替换中其中一个变量一般是真理

其中的啊有可能是变量或者是随机 sample 吧

其中的变量

然后尝试对这些变量去做一些替换

或者是做一些简化的操作地方

他如果是就这个 bin 这个 arrival

他尝试去把它简化成

把其中一个 FS 给拿掉

所以然后呢

当然 DPS 拿掉了前面这个相关的一个依赖性

这个 PS 这一行也可以拿掉了

这就是一个产生一个 SHAVARI

这是其中一个规则

然后给到了之后呢

就可以得到这个变种

然后直接把这个变种拿到这个编译出来

最好放在机里面跑一跑啊

然后他的场景里面跑一跑

这个场景里面需要编辑不同的 SYMPURATION

不同的材质

不同的 camera 去把这个估计一下这个变种的质量

就可以得到一个普通模式啊

当然还要评估一下他的普通门面是直接跑起来

这个东西啊就可以撤了

就是这样

然后下一步的话这个东西要不断迭代

就是如果 simple 这个好

那他可能会更尝试的去做其他的简化

还有其搜一个这个再去做简化

他去搜想试法

第二行啊

做一下解放奥数

第二行把这个后面这些地方也去去

再去做一下普通的 c cot

还有更凶的就是不断迭代

那自己最暴力的情况

那可能就是一个直接给一个 ambient

作为他的一个输出

这个整个东西去多去评估遍

话说刚才给他可以给他做前面那中间一些细节

### 00:28:52,50

![00-28-52](tmp/00-28-52.jpg)

就是说怎么样转换代码

有哪些型号

然后啊怎么找到最优

这个整个一个框架

就是构成了这个我们真正去做的事情

### 00:29:03,50

![00-29-03](tmp/00-29-03.jpg)

呃

代码简化

首先是呃嗯这个其实也是编辑的东西了

比如说比如说给定一个代码 2×7 加三

那呃上个编辑的原理的话

### 00:29:15,50

![00-29-15](tmp/00-29-15.jpg)

那应该知道就可以生成一个 pass to pass pass key 啊

然后他等下一个 STG 都快抽象语法术

这个是更抽象更简洁的一个表达

### 00:29:31,50

![00-29-31](tmp/00-29-31.jpg)

在我们真正做的时候呢

是会把这个学的代码用一些 glam

或者是一些啊 dire compiler 这些工具

它可以帮我们自动的去把这个后的风气

养成一个自身法术

然后还有一个是他的一些内地的对其依赖关系

和这个抽象明白旅顺或者 sample 的去尿

然后去修改

然后我们再根据这个 rap 找出来啊

我

有的东西都不需要了

那我们就会把对应的那个 code

从这个 dependent ground 找到

它也是对应的

上图扣的也是事情

最后去产生一个新的代码啊

然后这个产生的代码呢

一般来说你要去做一下语法检查啊

这个是比较基本的啊

如果不行的话

可以直接丢到水准里面

坦白去做

有条件差

这个都没问题

### 00:30:35,50

![00-30-35](tmp/00-30-35.jpg)

然后群体的一些简化规则

最常见的就是啊也是比较有效的一个就是简化

就是表达式简化

像一个 normalize

像这个东西

他可能把这个 IDIR 拿掉

你可以把 LDIR 拿掉

就不知道就可以产生不同的变种

我们这个叫自动计算机自动去看嗯

### 00:31:01,50

![00-31-01](tmp/00-31-01.jpg)

然后第二个是 loop production

就是有一些循环啊

可能不清啊

那个比较小的问题就行了

这个主要是放在一些收敛一些

那个迭代算法一些

比如像你找一个什么最优化

要有个递归最优这种东西的话

其实可以去降低一下它的循环的次数

### 00:31:26,0

![00-31-26](tmp/00-31-26.jpg)

然后像一些表达式的替换

把这个替换成这个

或者反过来把这个替换成这个

就是 NTL 替换成 N 乘 H

这也是它的产生的效果是很多的

H 是办法

你表达的是那个一个物体表面的一个 normal

这些东西都是有的

### 00:31:52,50

![00-31-52](tmp/00-31-52.jpg)

然后一个比较一些效果比较好的

就是这个把一些 fragment 的 piece 的一些代码

从一上移到这个 TX 水的上面去

这个其实我们刚才已经讲到了

在手动优化的时候已经讲到了

就是一些看一下的话

就是个 pad 加 DC 这个这两块

完全这些基层颜色全部都移到这个去了

然后开始追的算出一个演奏

这就是我们最终的它的呃

### 00:32:24,50

![00-32-24](tmp/00-32-24.jpg)

从你的意义上理解呢

就是他干了一些事情

我算一个三个点的

三个顶点的一个值

然后啊啊就每一个兵它的一个重心坐标

每个

这个顶点的 value 就是不上

### 00:32:49,0

![00-32-49](tmp/00-32-49.jpg)

然后啊更进一步呢

就是说我们现在因为有些 TELLATION 嘛

有些绝对比

就是说如果说我们不是移到一个 JM 去学的啊

不是移到 TX 水的

我们移到这个啊

### 00:33:03,0

![00-33-03](tmp/00-33-03.jpg)

Technation shader

那其实就是可以做一个力度更细的一个

进行逼近了

因为一个原始的三角面片

我现在可以分成很多个分技巧的三角面片

然后我们算这些细小的三角面片

上面的是纸

你可以看离线

### 00:33:22,50

![00-33-22](tmp/00-33-22.jpg)

然后还有一种是做这个呃信号以后的话

就是我们呃用一些看看啊

content 的一些量去替代掉它原来的一些呃变量

这样子的话如果是一些值啊

比如说某一个变量

它在这当前的 thing configuration 上面

它的变化比较 smooth 变化不大

那他就可以被替换掉

一种常见的就是说比如说一些背景啊

像一些平庸的群是物体

它的背景离我们很远

那清晰跟方向相关的变量

其实就基本上方向无关了

这些东西有可能最后都被这个能量去改掉

然后再来的话是一个一些高阶的逼近

### 00:34:05,50

![00-34-05](tmp/00-34-05.jpg)

就说我们用一些 desire 曲面啊

或者什么去逼近这个函数啊

就是这个你可以认为就是刚才那个啊

一些进行逼近的一个进化版

### 00:34:21,50

![00-34-21](tmp/00-34-21.jpg)

像这个用北大船走了之后

可以做一个非线性的一个高阶的一个 baking

这些是一些常见的策略

### 00:34:34,0

![00-34-34](tmp/00-34-34.jpg)

OK 呃给到了这些策略之后

简化策略呢

那我们有了简化策略

有了简化的 SHADER

那接下来就是这个大概就可以连起来了啊

首先是把这个 SHADER 扣放到这个啊

一些编辑器上面去

ST 和一些赖数编辑部居然后就去尝试啊

对

然后再给你整个系统去输入一些

你这个定 configuration

Fighting real material

然后去产生大量的啊

去尝试去搜索这个 SHADER 的一些 arrival 和 expression

然后去做 apply

各种各样的一些表达式进行简化表达式啊

然后去生存新的一个 create vari1 些变种水的变种

然后去评估这个水的变种啊

最后再递归表达对产生各种各样的一些呃

LD 等于 C 的

### 00:35:32,50

![00-35-32](tmp/00-35-32.jpg)

这里面一个核心的问题就是这个喷是非常多的

他可能有上万个

然后我们在产生的变种的时候呢

呃一般不会去盲搜

因为盲搜的话啊

或者是那个暴力周的话变得太多啊

特别是我们现在的些现代的追的很长

你这个 combination 太多

所以会用一些啊

genetic program1 些拼音算法计算法的话

我们就给你出一

就是如果一个父节点

它也产生了一个 F1 个 C 的

它的质量和 error 都比较好

我们还有他的数字简单一个小书

希望去听这个 shader violent 去进一步简化

就是有这么一个嗯父子的关系

有优秀的 trade van 产生更多的一个变种

基于他就是这么一个事嗯

具体的话我就不展开了

所以是不是我们学的这里面的内容

然后的话呃展开评估一个变种吧

因为它也很耗时

我要有各种各样的视角

各种各样的性能啊

有时候呢我们评估的规则也不一样

是如果说我评估一个

简单的评估一个那个颜色的话

还好一个 LQ 什么的就行了

但有时候是要评估他这个能耗啊

这个东西就会更啰嗦一些

甚至有时候要比那七八糟的

那么实际使用的时候去确定的

这个没有一个是所谓的一个最优的东西

所以给他这么大的这么一些复杂的评估方法

评估很很拉

然后变种也很多

那怎么加速产生这个优化空间

就是啊初中优化的一个核心问题和

### 00:37:27,50

![00-37-27](tmp/00-37-27.jpg)

所以我这地方啊

今天会讲两个核心的一个问题吧

呃觉得比较重要的一个就是

有一个是两个优化的策略

第一个就是用贪心算法去做优化

### 00:37:39,0

![00-37-39](tmp/00-37-39.jpg)

我们原来的话会说哦

产生很多那个啊各种各样的东西去填满

这个空间

好一点的话呢

就是说能够想到连这个潘尼托前沿去

他的一些指点点啊

如果当前这个从这个最难用的一个原始的水准

开始去搜一个啊它的一个最优的一个子节点啊

哪个地方

然后再沿着这个地方用一个餐厅的方法去搜

下一个下一个下一个下来

当然这个地方啊肯定会漏啊

但是它的时间上

只能是说我们可以做一个时间和质量上的 B 啊

这为琼州的话

他这个是 np hard 的问题

所以啊你用弹性去逼近

那肯定会漏

然后他另外一个策略

就是说他不去直接去啊

评估这个着色器的运行时间

那样你就省掉了一些 KY 的时间

甚至省省掉了一些这个实际浪的时间

他直接根据商业调查数据

还有一项能力和操作数

然后去做一个加成啊

平均值来估计呃

这也会有产生一些误差

然后的话对于着色器的误差呢

就是它的绘制质量的误差

它啊弄了一个是这个误差缓冲

它就是说做某个啊

比如说某个表达式的简化

它产生了多少误差

然后他会把这个

操作和误差的值做一个 tale 推塔

然后去存起来

那下一次在其他 shade van 的时候

再去碰到同样的一个操作啊

去删减同样一个节点的时候

就可以拿这个缓冲拿来去理存

去替代表最真实的 run 嗯

这个就是它的一个基本的能力

然后这是第一个

### 00:39:31,50

![00-39-31](tmp/00-39-31.jpg)

然后第二个我觉得比较重要的是这个啊

实时的一个 FICATION

所以我们知道这个刚才所讨论

那些虚的简化方法呢

其实都是一些离线的东西啊

那我们在实施的时候

因为我们在游戏过程中啊

是每一帧或者是每一个场景它在时时变化的

那有没有办法去说我们在边变化

再根据在这个游戏运行的过程中

去优化这个税的

这就是来到这个呃

Real time shader

Runtime

### 00:40:04,0

![00-40-04](tmp/00-40-04.jpg)

Shader optimization

它的一个核心思路

就是需要去降低它的一个优化空间

在最开始的时候呢

他会给到一个新的代码

然后去在第四季是谁的 rate 吗

Sha sha rummliquan ru

去产生一些大量的水的 value

那雷神把这个看啊

完了呢

这个裁缝店的话

他就根据这个 SHADER 之间的一些相似度

还有它的一些包括一些东西去做 CLAVERING

把这个整个空间变得很小啊

然后在每集上呼吸里面的带

### 00:40:48,0

![00-40-48](tmp/00-40-48.jpg)

那么在 RUNTIME 的时候呢

呃我们就不去搜索这个东西了

我们直接拿这个呃简化的空间

还有一些简化掉了一些啊

SHADOTOMMY 去做一个匹配啊

在一些比较小的一些空间里面

去找一个最优的一个解

所以呢就可以达到一个实时的一个实时优化

软优化的一个事情

### 00:41:13,50

![00-41-13](tmp/00-41-13.jpg)

然后第三个呢就是呃我提一下

就是这个 shader transformer

这个是它这个机器学习水等简化与嗯啊

简单来说呢就是说把这个语言模型啊

我们像因为可以你认为这就是一个全封了

现在是做那个资源源处理吧

啊挺牛逼的

我们就用 shader transformer

就用 transformer 的结构直接去解读这个呃

Shader code

让他们去网络来估计我们这个学者的质量

### 00:41:46,0

![00-41-46](tmp/00-41-46.jpg)

简单来说就是这个网络大概是这个结构

它要接受很多很多很多样的东西

一个是嗯一个 fat code

然后还有一些我们的场景 configuration

然后经过一系列的全 form tension

后面才输出一个优化的一个表达

这个表达呢是可以做自由的一些删减的

就基我们就去黑

他也没说啊

节点打掉之后啊

群加群就可以得到这个简化

后续啊

其实就是把这个呃把这个 C 的扣的一个编码

然后映射到他的

他的这个想要控制里面的一个嗯

那句啊就是做这么个事儿啊

### 00:42:40,0

![00-42-40](tmp/00-42-40.jpg)

这样的话就可以把这个一些计算误差的

一些代码

那些特别是一些观看的时候

那些这封面图加起来

然后的话到了这个是之后呢

我们来看看结果吧

就是说这个数据的到底有多大的能力啊

就是说像在这些人的模型等等模型

在这些皮啊

皮肤表达模型上面啊

可以达到不同的

然后这个 LD 上

对应的是第三个节点

然后

快的

然后后面几天应该

啊那个 tank 我就不考虑了

这几个点就会取出来做这个 LD

### 00:43:36,50

![00-43-36](tmp/00-43-36.jpg)

然后这是另一个 example

就是同样就是就是多目标了

因为它既优化了这个时间与优化

所以他画出来这个很符是一个啊

那没的一个空间

但同样其实在这个空间里面

也可以去找这个判断图啊

这个是变的

这就可以做多目标的 BO

应该是对今天的这个主课就讲了

### 00:44:08,50

![00-44-08](tmp/00-44-08.jpg)

他
