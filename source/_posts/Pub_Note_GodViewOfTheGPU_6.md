---
title: 上帝视角看GPU（6）：光线跟踪流水线
---

大家好，我是龚敏敏。又见面了。

上一期我们看了GPU光栅化图形流水线的一些细节。现在的GPU往往还支持光线跟踪，ray tracing。我们就来详细了解一下这部分。

最简单的光线跟踪类算法，称为光线投射，ray casting。以摄像机为原点，往每个像素发射一根光线，一步一步往前跟踪。光线打到物体表面之后，根据光源和该点的材质计算出一个颜色，作为该像素的颜色。这样的结果和光栅化非常相似，只是生成像素的方式有所区别。它只能得到直接光照，也就是像素颜色来自于光源的直接贡献。1992年的德军总部3D就用了这个算法。

在较低的分辨率上跟踪形状固定的物体，在CPU上执行速度也过得去，不用Z-buffer也能有正确的遮挡。即便只是光线投射，也已经能从中看出一些端倪。用光栅化渲染的时候，要解答的问题是，这个物体占据了哪些像素。而光线投射解答的是，沿着这条光线的方向，能看到什么物体。这个区别，使得两者的渲染流程完全不同了。

光栅化是一个一个物体送去渲染，一个一个三角形光栅化。GPU并没有场景的概念，拿到什么渲什么。光线投射就不能这样了。因为光线发出的时候并不知道会打到哪里，必须要把整个场景全部都提交给GPU，才能开始跟踪。渲染的单位不再是三角形，而是整个场景。

复杂一点，当光线打到物体表面之后，不是就此停止，而是可以继续折射、反射、散射等，产生多条新的光线，继续跟踪，直到打到光源为止。最后从光源反向计算每次打到物体的颜色，得到这个像素的颜色。这就是整体的光线跟踪。既然场景都有了，不需要额外的新数据就能完成这整个操作。自然达成了实时渲染梦寐以求的全局光照，GI。

不是直接来自于光源，而是来自于其他光路间接贡献的光照，称为间接光照。之前为了实时计算间接光照，AO有AO的方法，反射有反射的方法，折射有折射的方法，散射有散射的方法。互相还可能存在冲突，无法一起使用。有了光线跟踪之后，整个GI可以用一致的方法统一完成。开发简单了，效果还更好。

回到物体本身。不管是光栅化还是光线跟踪，物体都可以用三角形的几何表示。那么光线跟踪的过程一定会涉及到光线和三角形求交。理论上，我们只需要这个求交判断，就能通过把所有光线和所有三角形都求交一遍来实现光线跟踪。但这样效率实在太低了，计算量大得惊人。所以长期以来，研究的重点就是如何尽可能早地把不会相交的情况排除掉，以加速跟踪。常用的是把整个场景放到一个树形的加速结构。

如果一根光线和一个子树已经不相交了，那就一定不会和子树里的任何物体相交，也就能排除掉整个子树。光线跟踪领域常用的加速结构叫BVH。这种树的叶子节点是物体本身。物体的包围盒之间的关系往上组成了一级一级的树。

用三角形表达物体，属于显式表达。给一堆三角形，显式地定义出一个几何体。另一种常见的形式是过程式物体，属于隐式表达。它给的是一个包围盒和一个隐式函数。传入一个<x, y, z>坐标，这个函数告诉你是不是在它表示的物体上。这两种物体表达，都可以用于光线跟踪。

有了这些基础，我们就可以开始来看看GPU的光线跟踪是怎么回事。首先，我们肯定会需要一个让硬件可以访问的加速结构，而且必须针对实时应用来设计。我们需要对几何体本身建立加速结构，然后摆到场景里，建立场景整体的加速结构。这就有了物体的加速结构和场景的加速结构两层的关系。

其次，游戏场景里会有很多动态物体。如果物体一动就得重建整个加速结构，开销太大了。于是这样的加速结构还需要支持局部更新。

有了加速结构之后，把它提交给GPU。它也是整个渲染流程的核心。第二期有提到过，光线跟踪流水线引入了多个新类型的shader。从ray generation shader作为起点，发出光线。光线遍历加速结构，找到可能有相交的叶子节点。如果是三角形几何体，GPU会把光线和三角形求交。如果是过程式物体，光线只会和物体的包围盒求交，然后调用intersection shader来确定是否真的和物体相交了。如果打到了，就转到any hit shader，判定是否要继续往前跟踪。光线打到物体的最近点，会调用一次closest hit shader来计算颜色。这里可以产生新的光线，递归获得颜色。如果什么都没打到，就会用miss shader算颜色。

前面说过，光线跟踪的时候并不知道一根光线发出去能打到什么物体。所以得把整个场景里的所有物体的几种shader，都放在一张表里。GPU会根据打到物体的ID，动态决定调用哪个shader。这和光栅化很不一样。光栅化的时候是开始画一个物体之前就能静态决定用哪一组shader。因此，光线跟踪的shader有动态调用的能力，称为callable shader。这些类型的shader仍然是在unified shader单元里执行的。

GPU上的RT core做的是求交的加速操作。其实不管是D3D12还是Vulkan里的光线跟踪 API，都只是定义了一个接口。回忆一下前两期说过的API知识。经过API隔离之后，上层并不需要知道下层是怎么做的。这个API定义的是期望的行为。厂商的实现可以在符合这套行为的情况下自由发挥。

程序把物体和场景扔进API，能建立出加速结构。再把加速结构扔进API，能跟踪出结果就行了。程序不需要知道加速结构是什么样的，只当作黑盒来用。今天各家都用BVH，以后如果发明了更好的结构，也可以在不改变接口的情况下把实现换掉。

另一方面，仍然是因为上下层隔离，甚至连GPU能提供多少对光线跟踪的支持都没有定义。各家实际上对光线跟踪的实现都很不相同，有的大量在硬件上执行，有的大量在可编程单元里执行。微软甚至有个用compute shader实现DXR的fallback library，装上之后就能在完全没有硬件光线跟踪的GPU上运行。这都没关系，只要符合API定义的行为就都是有效的实现，区别只在于效率。

即便在只有计算流水线的诈骗GPU上，仍然可以通过纯软件的方式实现光线跟踪流水线，并在驱动里暴露出来让上层使用。硬件光线跟踪的发展，看起来那么散乱无序，似乎怎么做都可以。那在方向上有什么指导思想吗？看这个。Imagination提出过光线跟踪的六个等级。通过这样的定义，我们可以看到现实中的光线跟踪正处于哪个阶段，也能大致了解未来会如何发展。

等级0，是“史前时代”的光线跟踪。有的是纯CPU，有的是专用的光线跟踪卡。有的有可编程能力，有的把整个光线跟踪流程实现成一个黑盒。这个时期的光线跟踪API模仿自OpenGL，借用了很多光栅化渲染里的概念，和现在的框架很不相同。代表作有Intel的Embree和Caustic的OpenRL。

后来Caustic公司被Imagination收购，开启了光线跟踪的新时代。等级1，来到了用GPGPU做光线跟踪的时代。通过可编程单元实现在GPU上跑的光线跟踪。这时候已经出现了前面说的加速结构建立和跟踪框架。微软的DXR fallback和NVIDIA OptiX的早期版本都属于这个等级。

等级2，GPU可以用硬件执行光线与三角形、光线与立方体的相交。跟踪的时候遍历BVH加速结构仍然使用可编程的方式写成，但其中的求交可以快得多。达到同样的功能，用可编程的方式需要花费用硬件的44倍的芯片面积。第一代硬件光线跟踪GPU处于这个等级。

虽然只有这么少的东西由硬件执行，但仍然使得GPU硬件光线跟踪进入了实用的阶段。等级3，BVH操作可以在GPU上硬件执行。这时候硬件执行的就不光是底层的光线和三角形、立方体求交，还能遍历BVH。BVH遍历是个算法固定的操作，适合硬件执行。NVIDIA的Turing及其之后的GPU已经做到这个等级。性能得到了一次提升。

等级4，GPU可以根据BVH操作的相关性排序执行。如果一批光线的起点和方向很不相同，那么在遍历BVH的时候，会走很不一样的分支。这会相当影响SIMD硬件的执行效率和内存访问效率。之前说过的MIMD，需要复杂得多的设计，而且仍然无法解决内存访问连续性的问题，并不能真正发挥作用。如果按照光线的位置和方向排序之后分批执行，在一个SIMD的warp内，对BVH的操作基本相同，能显著提升相关性，提高效率。Imagination的PowerVR Wizard架构GPU已经达到这个等级，可以在硬件自动做这个排序。

其实，即便在更低等级的硬件上，用软件把光线进行分类后再跟踪，也能提高性能。等级5，最高的等级，BVH可以在硬件上构建和更新。这就彻底把所有算法固定的部分都挪到了硬连线来执行，效率最高、功耗最低。目前只有Imagination的PowerVR GR6500测试板有硬件BVH构造器，实用化的产品还得等未来。

其实也正是因为Imagination走得最前沿，才能给出这样的指导意见。差不多10年前我就见过PowerVR的低功耗硬件光线跟踪开发板，但目前为止还没有实用化的产品出现。

总的来说，虽然光线跟踪的GPU已经出现一段时间了，但仍然雷声大雨点小。只有为数不多的游戏使用了光线跟踪，没有全面铺开。其中一个很关键的原因是性能不够。要从光栅化切换到光线跟踪，虽然效果可以好得多，hack可以少得多，但无法弥补低性能造成的用户体验下降。

经历了早期的以光线跟踪为噱头一窝蜂冲上去的时代之后，游戏慢慢开始回到正轨，考虑如何把光线跟踪和光栅化结合起来，组成更实用的混合式光线跟踪。基本的思路就是尽量减少跟踪的光线数量，用其他方法来填补。

比如说，用光栅化生成直接光照，用光线跟踪生成阴影和一次间接光照，叠加产生最终结果。还有降低跟踪的分辨率，通过周围和上一帧的信息，从空间和时间上填补当前跟踪的结果。UE5的Lumen，就能开启硬件光线跟踪完成一些需要精细跟踪的地方，作为软件cone tracing的补充，以较少的代价提高间接光照的效果。

未来如果光线跟踪硬件性能大幅提升，有了富余的计算能力，还会出现一个新的方向：通用光线跟踪。类比于之前用GPU可编程单元做通用计算，这是在用光线跟踪单元做通用计算。这时候的加速结构，不但可以用于光线跟踪，还能用来作为场景里物体的碰撞检测之类物理模拟的需求。

光线跟踪也解析完了。这个系列的内容，希望能帮助大家理解GPU上原先被当作黑盒的一些细节。总的来说，用GPU编程，思维方式上既不同于CPU的多线程，也不同于传统的流式处理器。要在这方面有所精进，主要还是得靠多学多用。

本系列就先到此为止吧。还有什么想了解的可以留言讨论，以后有机会我再续上。下一期将看一些不一样的内容。欢迎继续收看，再见。

