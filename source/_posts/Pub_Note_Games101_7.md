---
title: Games101 7.Shading 1 (Illumination, Shading and Graphics Pipeline)
---

## Visilibility/Occlusion

现在我们已经可以把三角形画在屏幕上了，但是如果有很多三角形，还会涉及到一个问题，就是遮挡关系，如何让近处的永远遮住远处的。

### Painter's Algorithm

![Alt text](image.png)

- 要把场景中各种各样的物体都放在屏幕上，涉及到一个顺序问题。最简单的想法是先画最远的物体，然后逐渐把近的物体补在屏幕上，让它覆盖以前的远处的物体。
- 就像是画油画一样，先画远处的山，然后在这个基础上画近处的草地，再在草地上画树，树又挡住了草地，还挡住了一部分山。
- 场景中的某个点到观测点的距离，就是这个点的深度。

画家算法的问题：
![Alt text](image-1.png)

- 首先需要对场景中的物体进行排序，需要 $O(n \log n)$ 的时间复杂度。
- 另外还可能存在相互嵌套的问题。

### Z-Buffering

图形学里边大家使用深度缓冲（z buff）来解决这个问题。
![Alt text](image-2.png)

- 对三角形进行排序困难，z-buffering 相当于对每个像素进行排序。(不是真正的排序，实际上只是在求最小值)
- 生成的时候同时生成两个图像，一个是最终的结果记录在 frame buffer 里，另一个是记录每个像素看到的几何物体的最浅深度信息，叫做 depth buffer。

我们之前说相机永远往-z 方向看，这里为了方便，做一个假设：深度永远是正的，越小的深度表示越近，越大的深度表示越远。

depth buffer 长这样：
![Alt text](image-3.png)

- 我们同时渲染出这两幅图
- 深度越小，反应在颜色上就是黑色，深度越大，则是白色

z-buffering 算法大概是这样一个流程：
![Alt text](image-4.png)

可以来看一个例子：
![Alt text](image-5.png)

- 一开始深度都是无限大的，如果不方便定义，可以定义成一个足够大的值，比如 10 的 10 次方
- 所有的操作都是针对任何一个像素来说的

### Z-Buffering Complexity

![Alt text](image-6.png)

- 画家算法需要排序，复杂度是 O(n log n)
- 有个前提，认为每个三角形大小都不是特别大，不是特别小，会覆盖一定的常数个像素，比如 100 个像素
- z-buffering 的算法复杂度是 O(n)，因为只是在对每一个像素求最小值
- z-buffering 和顺序是没有关系的，不管先画哪个三角形，后画哪个三角形，只要维护对了深度缓存的算法，最后得到的结果一定是一样的

其中，我们有一个假设，不会有两个三角形在同一个像素拥有相同的深度。

这个假设是有一定的道理的，因为在几何表示中，很多数字都是用浮点型精度来表示的。浮点型和浮点型判断相等是一个非常困难的事情，所以几乎不可能说两个浮点型的数字是一样的。

z-buffering 的一个非常重要的算法，广泛应用在几乎所有的硬件中，所有的光栅化都会做深度测试，这样就可以得到正确的遮挡。

这里额外说一句，为了反走样用到了 msaa，一个像素里有好多采样点，对于每个采样点都要作用于 zbuffer

z-buffering 处理不了透明物体

## Shading

通过 MVP 变换以及光栅化，目前我们已经可以把物体显示在屏幕上了：
![Alt text](image-7.png)
这是一堆旋转的立方体
![Alt text](image-8.png)
为什么这个看上去那么不真实呢？虽然是立方体是同一个颜色，但是它们在不同面上的朝向不同，应该有不同的颜色，这样看上去才更真实些。
![Alt text](image-9.png)

我们下一步要做的就是着色。

![Alt text](image-10.png)

那么，什么是着色呢？
![Alt text](image-11.png)

- 某些地方会明亮一些，有些地方会暗一些。光源打到某个地方可能还会有高光，有些接受不到光的地方还会产生投影。
- 在图形学上，我们把对不同的物体应用不同材质的过程叫做着色。
- 木头球跟金属球，虽然是球，但是看上去不一样，就是因为它们有不同的材质，跟光线的相互作用不一样。

### Blinn-Phong Model

下面介绍一个非常简单的着色模型，叫做 Blinn-Phong Model。（两个人的名字拼在一起）

![Alt text](image-12.png)

- 有个表面特别光滑，光线打到表面上，会往镜面反射方向反射，这个我们叫做高光。
- 除了高光，表面的颜色变化不是那么剧烈，这个我们叫做漫反射。比如，当光线打到墙上，因为墙的表面比较粗糙，光线会被反射到四面八方。
- 最下面的部分，按理来说光线是不会打到的，但是我们看到的时候，这个地方还是有一些颜色，这个我们叫做环境光。它的光是来自于其他地方反射过来的，叫做间接光照。（这个着色模型中反射光基本上是一个常量，任意一个点都会接收到来自环境的反射光）

在开始之前我们先做一些定义：
![Alt text](image-13.png)

- 首先，我们的光照计算考虑在一个局部的点上，这个点我们叫做 shading point。
- shading point 一定在一个物体表面上，物体表面可以是曲面，但是我们认为在一个局部的非常小的范围内，它永远是一个平面。
- 在这个平面上，我们可以定义一个法线，法线就是垂直于这个平面的一个方向。
- 以及另外两个方向，一个是观察方向（view direction），一个是光照方向（light direction）。
- 既然是方向，我们可以把它们定义成单位向量，长度永远是 1。
- 然后关于这个 shading point 自身有一些属性：
  - 比如它本身是什么颜色，比如木头各处的纹路，叫做 color
  - 它有多亮，叫做 shininess

![Alt text](image-14.png)
另外，目前我们说的 shading 是局部的，只考虑这个点自己，不考虑其他物体的存在，不考虑是不是在阴影内。阴影的生成我们之后再说。

我们先从漫反射（diffuse）开始：
![Alt text](image-15.png)

- 光线达到 shading point 的时候，会被反射到四面八方
- 这个反射的强度跟光线的入射角度有关。

![Alt text](image-17.png)

- 假如说光线是离散的，每根光线代表了一个固定的能量，发现光线与表面垂直时接受到全部的能量，当产生一个角度时，接受到的能量就会减少。这个规律叫做 Lambert 余弦定律。
  也就是说 light direction 和 normal direction 之间的夹角决定了物体的表面有多亮。
- shading point 代表了单位面积，所以接受到的能量是跟面积无关的。

另外还有一个问题，就是能量从哪里来的？
![Alt text](image-18.png)
假设光来自于一个光源，我们认为它是一个点光源，那么这个点光源无时无刻不在以一定的方式往四面八方辐射出不同的能量。我们在一个球壳上去考虑。不考虑能量衰减，那么不同层的球壳上总的能量是一样的。

传播过程中，球壳越来越大，表面积也越来越大，所以单位面积（点）上的能量就越来越少。考虑能量守恒，我们可以得到光的强度是 $I$，那么在距离为 $r$ 的时候，光的强度是 $I/r^2$。（后面会给大家定义光线传播的各种物理量，其实这里用强度来描述并不合理）

把这两点结合起来，我们就可以得到漫反射的结果：
![Alt text](image-19.png)

- $max(0, n \cdot l)$ 是因为当角度为负的时候，我们认为光线是从下面穿过物体到达表面，这种情况下是没有物理意义的，我们认为它是 0。
- 然后 shading point 是有颜色的，也就是说它会吸收一部分光，反射的是它不吸收的部分。所以我们通过一个系数 $k_d$ 来表示有多少光被反射出去了。如果我们将其表示为一个向量，那么它的红绿蓝分别是 0 到 1 之间的值，就可以定义一个颜色。
- 漫反射无论从哪个方向看，得到的结果都是一样的，也就是说跟观测方向没有关系。

![Alt text](image-20.png)

Blinn-Phong Model 本身并不是一个物理上的模型，它是一个经验性的模型，所以 kd 也没有考虑到能量守恒。
所有点都是在世界坐标系里面，光源也是在世界坐标系里面，所有的计算都是在这个世界坐标系里面。
